# Chapter2. 自动内存管理机制

#### ------- Java与C++之间有一堵由内存动态分配和垃圾收集技术所围城的高墙，墙外面的人想进去，墙里面的人却想出来

----

## 2.1 概述  

	1. C C++开发人员拥有每一个对象的所有权，每一个对象生命从开始到终结都要维护 
	2. Java程序员在虚拟机自动内存管理机制的帮助下，不再为每一个new操作去写配对的delete/free代码，不容易出现内存泄露溢出问题
	
## 2.2 运行时数据区域 
----
### 2.2.1 程序计数器（Program Counter Register）

	1. Program Counter Register是一块较小内存空间  
		当做当前线程所执行的字节码的行号指示器，PC的作用是通过改变计数器的值来选取下一条需要执行的字节码指令  
	2. Java虚拟机的多线程实现方式：通过线程轮流切换并分配处理器执行时间  
		任何一个确定的时刻，一个处理器或者一个内核都只会执行一条线程中的指令，每个线程都有自己的PC，独立存储  
		这段区域-》线程私有  

### 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks）

	1. 线程私有，生命周期与线程相同  
	2. 是Java方法执行的内存模型：  
		方法执行时，会创建一个栈帧Stack Frame 用于存储局部变量表、操作数栈、动态链接、方法出口等信息  
		每一个方法从调用到执行完成，就是对应一个stack frame在虚拟机栈中入栈到出栈的过程  
	3. 局部变量表：  
		存放了编译期可知的各种基本数据类型(boolean byte char short int float long double) 、
		对象引用（reference类型，指向对象起始地址的引用指针或者句柄之类), returnAddress类型  
		所需内存空间在编译期间完成分配，进入一个方法时，这个方法需要在帧中分配多少的局部变量空间完全确定，运行期间不会改变  
	4. 异常  
		线程请求的栈深度 > 虚拟机所允许的深度   StackOverflowError  
		虚拟机动态扩展时无法申请到足够的内存	   OutOfMemoryError  

### 2.2.3 本地方法栈（Native Method Stack） 

	为虚拟机使用到的native方法服务  
	
### 2.2.4 Java堆（Java Heap）

	1. Java Heap 内存中最大的一块  
		被所有线程共享的一块内存区域，虚拟机启动时创建  
		用于存放对象实例  
	2. 垃圾收集器管理的主要区域 又名 GC堆（Garbage Collected Heap）  
		内存回收角度：收集器基本采用 分代收集算法  
			Java 堆中分为：新生代 老年代  
		内存分配角度： 堆中可能划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）  
	3. Java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，虚拟机扩展-Xms  
	4. 堆中没有内存完成实例分配，堆无法再扩展，OutOfMemoryError  
	
### 2.2.5 方法区（Method Area）

	1. 被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据  
		Non-Heap  
	2. 本质上与永久代不等价，只是HotSpot曾经使用永久代实现方法区  
	3. 垃圾收集较少出现  
	
### 2.2.6 运行时常量池（Runtime Constant Pool）

	1. 方法区的一部分  
	2. Class文件中除了类的版本、字段、方法、接口等描述信息，还有常量池constant pool table，  
	用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放  
	3. Class文件的格式有着严格的规定，每一个字节用于存储哪种数据都依照严格的规范要求，虚拟机才会认可、装载、执行  
	但是，运行时常量池就没啥特殊要求，直接引用也会存进去  
	4. 运行时常量池具备动态性，预置在class文件中常量池的内容可以进入方法区的运行时常量池，运行期间生成的也可以，比如String.intern()  
	5. 常量池无法再申请到内存：OutOfMemoryError  
	
### 2.2.7 直接内存

	1. Direct Memory 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域  
	2. NIO类 （New Input/Output类），基于通道Channel与缓冲区Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作【以后要展开学习】  
	    可以在某些场景提高性能，避免在java堆和native堆来回复制数据  
	    
	    
----

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

	1. 语言层面上，创建对象（克隆，反序列化）就是new一下  
	2. 虚拟机层面对象创建过程：  
		【1】虚拟机遇到new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用  
			检查这个符号引用代表的类是否已被加载、解析、初始化过  
			如果有，执行相应的类加载过程  
		【2】类加载通过后，虚拟机为新生对象分配内存。对象所需内存的大小在类加载过后可以完全确定{2.3.2}  
		【3】如果内存规整：分配内存把分界点指针向空闲空间移动与对象大小相等的距离  Bump the Pointer  
			应用：Serial、ParNew等带compact过程的收集器  
		【4】如果内存不规整：虚拟机维护一个列表，记录上哪些内存块可用，分配的时候从列表中挑一块可以的，跟新表的记录，Free List  
			应用：基于Mark-Sweep算法的CMS收集器  
		【5】线程安全问题：  
				a. 对分配内存空间的动作进行同步处理，虚拟机采用CAS+失败重试保证更新操作的原子性  
				b. 每个线程在java堆中预先分配一小块内存（TLAB）哪个线程要分配内存就在他的TLAB上分配，  
				TLAB用完并分配新的TLAB时，同步锁定  虚拟机设置-XX:+/-UseTLAB参数  
		【6】内存分配完成后，虚拟机需要将分配到的内存空间初始化为零值（保证对象的实例不被赋初值可以直接使用，  
		程序访问到字段对应数据类型的零值）  
		
### 2.3.2 对象的内存布局  

	1. 对象在内存中存储的布局区域： Header/ Instance Data/ Padding    
	2. Header:  
	
		【1】Mark Word: 存储对象自身的运行时数据，如HashCode，GC分代年龄，锁状态标志，设计成非固定的数据结构  
	        【2】类型指针： 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。  
	        【3】如果对象是java数组，对象头中还要有一块用于记录数组长度的数据  
	
	3. Instance Data:  
		 对象真正存储的有效信息，程序代码中定义的各种类型的字段内容；子类父类都要记录；存储顺序跟随虚拟机FieldsAllocationStyle以及字段在java源码中的定义顺序决定  
		 相同宽度的字段总是分配到一起，父类定义的变量出现在子类之前  
	4. Padding:  
		 占位符，对象起始地址必须为8byte的整数倍，对象大小必须是8byte的整数倍
		 
### 2.3.3 对象访问定位  

	1. java程序需要通过栈上的reference数据来操作堆上的具体对象，主流对象访问方式：句柄、直接指针  
	2. 句柄：	
		  java堆中分配出一块句柄池，reference中存储的就是对象的句柄地址，句柄中存了到对象实例数据或者类型数据的指针  
		  优势： reference中存储的是稳定的句柄地址，对象被移动（GCtime）时只会改变句柄中的实例数据指针，reference不需修改  
	3. 直接指针：  
		  reference中直接存对象地址  
		  优势：速度快，节省一次指针定位开销  
	
	
		
				
	








