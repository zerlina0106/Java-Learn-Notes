# Chapter3.3-3.4 垃圾收集算法与实现原理  
#### ------- Java与C++之间有一堵由内存动态分配和垃圾收集技术所围城的高墙，墙外面的人想进去，墙里面的人却想出来

----

## 3.3.1 标记-清除算法 Mark-Sweep  

        1. 标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。  
        2. 问题：  
                效率不高  
                空间问题：标记清除之后会产生大量不连续的内存碎片，内存碎片太多可能导致以后程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  
                
## 3.3.2 复制算法 Copying  
        
        一、原理  
        1. 将可用内存按照容量分为大小相等的两块，每次只使用其中的一块  
        2. 当着一块的内存用完了，就将还存活的着的对象复制到另一块，然后把已使用过内存空间一次清理掉  
        3. 每次都是对整个半区进行回收，也没啥复杂情况  
        4. 只需要移动堆顶指针，按顺序分配内存即可
        
        二、应用  
        1. 商用虚拟机都采用这种办法回收新生代，IBM公司研究表明，新生代中的对象大多朝生夕死，所以划分内存空间要改为  
        2. 一块大的Eden空间和两块小的Survivor空间，每次使用Eden和其中一块Survivor  
        3. 回收时，Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间  
        4. Survivor不够用时，依赖老年代进行分配担保（Handle Promotion）  
        5. 如果另一块Survivor空间上没有足够空间存放上一次新生代收集存活对象，这些对象通过Handle Promotion进入老年代
        
        
## 3.3.3 标记-整理算法 Mark-Compact  

        1. 老年代一般不用复制算法  
        2. 标记同标记-清除算法，只不过不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存  
        
## 3.3.4 分代收集算法 Generational Collection  
        
        1. 当前的商业虚拟机都用这个  
        2. 根据对象存活周期的不同将内存划分为几块，一般是java堆分为新生代和老年代，新生代大批死去少量存活，复制算法，  
        老年代由于对象存活率高，没有额外空间为他分配担保标记整理或者标记清除  
        
# 3.4 HotSpot算法实现

## 3.4.1 枚举根节点 

        1. 可达性分析中：  
                可作为GC Roots的节点主要有全局性的引用（常量或者类静态属性）与执行上下文（栈帧中的本地变量表）  
                GC停顿：在整个的分析期间，执行系统需要冻结，引用关系不可以变化，否则分析结果的准确性将无法保证，导致GC进行时停顿所有的java线程  
                        即便是CMS收集器，枚举根节点的时候也是要停顿的  
        2. 实现过程：  
                准确式GC 执行系统停顿下来后，并不需要一个不漏的检查完所有的GC ROOTS（执行上下文和全局的引用位置）虚拟机通过某些实现得知哪些地方存放着对象引用  
                HotSpot使用一组数据结构OopMap:在类加载完成的时候，HotSpot把对象内什么偏移量上是什么类型的数据算出来，JIT（just in time）编译过程会在特定位置记录下栈和寄存器中哪些位置是引用，GC扫描时候就直接知道这些信息了  
                
               
 ## 3.4.2 安全点  
 
        1. 不是每个指令都生成对应的OopMap，只在特定的地方记录信息-> 安全点SafePoint  
        2. 安全点的选定是以是否具有让程序长时间执行的特征为标准，程序不会因为指令流太长而过长时间运行，最明显特征是指令序列复用  
                如方法调用、循环跳转、异常跳转等功能的指令才会产生 Safepoint  
        3. 如何在GC发生时让所有线程除了被JNI调用的都去最近的安全点停顿下来  
                抢占式中断（Preemptive Suspension）（没啥人用）不需要现成的执行代码去主动配合，GC发生时，所有线程全部中断，如果有线程中断的地方不在安全点，恢复线程，让其去安全点  
                主动式中断（Voluntary Suspension）当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动轮询那个标志，发现中断标志为真就自己中断挂起，轮询标志的地方与安全点重合  
       
 ## 3.4.3 安全区域  

        1. Safepoint保证了程序执行时，不太长时间就会遇到可以进入GC的安全点  
        2. 程序不执行时，程序未被分配到CPU时间，如线程处于sleep或者blocked状态，线程无法响应JVM的中断请求自己去挂起，JVM也不太会等到分配了CPU时间         3. Safe Region 一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的  
        4. 线程执行到safe region中的代码时，标识自己进入safe region，JVM要GC时不用管标识自己为safe region状态，线程要离开safe region时，检查系统是否完成根节点枚举（或者整个GC），完成了线程就继续执行，否则等待直到接收到可以安全离开safe region的信号为止
    
                
                
              
   
                
        
        
        
       
        
        
             
