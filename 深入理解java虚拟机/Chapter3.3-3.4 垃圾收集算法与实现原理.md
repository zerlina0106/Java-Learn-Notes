# Chapter3.3-3.4 垃圾收集算法与实现原理  
#### ------- Java与C++之间有一堵由内存动态分配和垃圾收集技术所围城的高墙，墙外面的人想进去，墙里面的人却想出来

----

## 3.3.1 标记-清除算法 Mark-Sweep  

        1. 标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。  
        2. 问题：  
                效率不高  
                空间问题：标记清除之后会产生大量不连续的内存碎片，内存碎片太多可能导致以后程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  
                
## 3.3.2 复制算法 Copying  
        
        一、原理  
        1. 将可用内存按照容量分为大小相等的两块，每次只使用其中的一块  
        2. 当着一块的内存用完了，就将还存活的着的对象复制到另一块，然后把已使用过内存空间一次清理掉  
        3. 每次都是对整个半区进行回收，也没啥复杂情况  
        4. 只需要移动堆顶指针，按顺序分配内存即可
        
        二、应用  
        1. 商用虚拟机都采用这种办法回收新生代，IBM公司研究表明，新生代中的对象大多朝生夕死，所以划分内存空间要改为  
        2. 一块大的Eden空间和两块小的Survivor空间，每次使用Eden和其中一块Survivor  
        3. 回收时，Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间  
        4. Survivor不够用时，依赖老年代进行分配担保（Handle Promotion）  
        5. 如果另一块Survivor空间上没有足够空间存放上一次新生代收集存活对象，这些对象通过Handle Promotion进入老年代
        
        
## 3.3.3 标记-整理算法 Mark-Compact  

        1. 老年代一般不用复制算法  
        2. 标记同标记-清除算法，只不过不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存  
        
## 3.3.4 分代收集算法 Generational Collection  
        
        1. 当前的商业虚拟机都用这个  
        2. 根据对象存活周期的不同将内存划分为几块，一般是java堆分为新生代和老年代，新生代大批死去少量存活，复制算法，  
        老年代由于对象存活率高，没有额外空间为他分配担保标记整理或者标记清除  
        
        
        
       
        
        
             
